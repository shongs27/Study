# 모두를 위한 cs50

**컴파일러**

우리가 직접 작성한 코드는 **“소스 코드”** 라고 불립니다. 이를 2진수로 작성된 “머신 코드”로 변환해야 컴퓨터가 이해할 수 있습니다. 이런 작업을 컴파일러라는 프로그램이 수행해줍니다.

![https://cphinf.pstatic.net/mooc/20200608_25/1591593011509xRkDi_PNG/mceclip4.png](https://cphinf.pstatic.net/mooc/20200608_25/1591593011509xRkDi_PNG/mceclip4.png)

```c
// 각종 리눅스 명령어
ls, mkdir , cd
// library cs50을 써서 string.c 소스코드를 string 머신코드로 바꿔라
clang -o string string.c -lcs50
make string

// 출력타입 함수이름(입력타입)

1. int get_int(int c){}
2. void hi(void) //void는 없다라는 뜻
{
	printf("hi guys \n")
}

//Do While문의 활용 예
// 원하는 입력값 줄 때까지 계속해서 질문함

do
{
  n = get_int("몇번이나 스쿼트 했나요?\n");
}
while (n < -1); // while(true)일때까지 한번이상 계속 do{} 실행
printf("%d번이나 하다니 대단하다잉`\n", n);
```

## 메모리의 한계

RAM은 모든 프로그램이 실행 중 저장되는 곳이며 유한한 크기의 비트만 저장할 수 있기 때문에 때때로 부정확한 결과를 내기도 합니다.

### 정수 오버플로우

정수를 계속 키우는 프로그램에서 10억을 넘기자 앞으로 넘어갈 1의 자리가 없어집니다.

int에서는 32개의 비트가 다였기 때문입니다. 그 이상의 숫자는 저장할 수 없는 것입니다.

(float 32비트 double 64비트)

이런 오버플로우 문제는 실생활에서도 종종 발견됩니다.

1999년에 큰 이슈가 되었던 **Y2K 문제**는 연도를 마지막 두 자리수로 저장했던 관습 때문에 새해가 오면 ‘99’에서 ‘00’으로 정수 오버플로우가 발생하고, 새해가 2000년이 아닌 1900년으로 인식된다는 문제였습니다.

그리고 세계는 수백만 달러를 투자해서 프로그래머들에게 더 많은 메모리를 활용해서 이를 해결하도록 하였습니다.

이는 통찰력 부족으로 발생한 아주 현실적이고 값비싼 문제였습니다.
